<div id="day6" class="day-content">
    <h2>üìò Day 6: Performance & Optimization</h2>

    <div class="objectives">
        <h3>üéØ Learning Objectives</h3>
        <ul>
            <li>Implement caching strategies with Redis and HTTP cache headers</li>
            <li>Optimize database queries and use connection pooling</li>
            <li>Add rate limiting to prevent abuse</li>
            <li>Use compression and pagination for large datasets</li>
            <li>Monitor and measure API performance</li>
        </ul>
    </div>

    <h3>üìö Core Concepts</h3>

    <div class="concept-grid">
        <div class="concept-card">
            <h4>üóÑÔ∏è Caching</h4>
            <p>Store frequently accessed data in memory (Redis) or use HTTP cache headers (ETag, Cache-Control) to reduce server load.</p>
        </div>
        <div class="concept-card">
            <h4>‚ö° Rate Limiting</h4>
            <p>Limit requests per user/IP to prevent abuse. Use sliding windows, token buckets, or fixed windows strategies.</p>
        </div>
        <div class="concept-card">
            <h4>üîç Query Optimization</h4>
            <p>Use indexes, select only needed fields, avoid N+1 queries, implement connection pooling for database efficiency.</p>
        </div>
        <div class="concept-card">
            <h4>üì¶ Compression</h4>
            <p>Use gzip/brotli compression to reduce response size. Implement pagination for large collections.</p>
        </div>
    </div>

    <h3>üíª Code Examples</h3>

    <h4>1. Redis Caching Implementation</h4>
    <p><strong>Description:</strong> Implement server-side caching using Redis to store frequently accessed data in memory, reducing database load and improving response times. This example includes cache middleware, automatic expiration, and manual invalidation strategies.</p>

    <!-- SIMPLIFIED VERSION -->
    <div class="code-block">
        <div class="code-header">
            <span>JavaScript - Redis Cache Middleware (Simplified)</span>
            <button class="copy-btn" onclick="copyCode(this, 'code-d6-1-simple')">Copy</button>
        </div>
        <pre><code id="code-d6-1-simple"
                  class="language-javascript"
                  data-type="performance"
                  data-description="Essential Redis caching pattern with cache middleware and invalidation">const express = require('express');
const redis = require('redis');
const app = express();

// ======================================== REDIS CLIENT SETUP
const redisClient = redis.createClient({
    host: 'localhost',
    port: 6379
});
redisClient.connect();

// ======================================== CACHE MIDDLEWARE
const cacheMiddleware = (duration) => {
    return async (req, res, next) => {
        const key = `cache:${req.originalUrl}`;

        // Check if data exists in cache
        const cachedData = await redisClient.get(key);
        if (cachedData) {
            return res.json({ cached: true, data: JSON.parse(cachedData) });
        }

        // Store response in cache when sent
        const originalJson = res.json.bind(res);
        res.json = (data) => {
            redisClient.setEx(key, duration, JSON.stringify(data));
            originalJson(data);
        };
        next();
    };
};

// ======================================== CACHED ROUTE
app.get('/api/users', cacheMiddleware(60), async (req, res) => {
    const data = await getExpensiveData(); // Expensive operation
    res.json(data);
});

// ======================================== CACHE INVALIDATION
app.post('/api/users', async (req, res) => {
    await redisClient.del('cache:/api/users'); // Clear cache on mutation
    res.status(201).json({ message: 'User created' });
});
</code></pre>
    </div>

    <details>
        <summary>üìÑ View Full Redis Implementation (with error handling, clear all, and monitoring)</summary>

        <div class="code-block">
            <div class="code-header">
                <span>JavaScript - Complete Redis Caching System</span>
                <button class="copy-btn" onclick="copyCode(this, 'code-d6-1')">Copy</button>
            </div>
            <pre class="line-numbers"><code id="code-d6-1"
                  class="language-javascript"
                  data-type="performance"
                  data-description="Production-ready Redis caching with error handling, monitoring, and bulk invalidation">const express = require('express');
const redis = require('redis');
const app = express();

// ======================================== REDIS CLIENT SETUP
// Create Redis client with connection configuration
const redisClient = redis.createClient({
    host: 'localhost',
    port: 6379
});

// Handle Redis connection errors gracefully
redisClient.on('error', (err) => console.error('Redis error:', err));
redisClient.connect();

// ======================================== CACHE MIDDLEWARE
// Reusable middleware for caching GET requests
const cacheMiddleware = (duration) => {
    return async (req, res, next) => {
        const key = `cache:${req.originalUrl}`;

        try {
            // Attempt to retrieve cached data
            const cachedData = await redisClient.get(key);

            if (cachedData) {
                console.log('‚úÖ Cache hit');
                return res.json({
                    cached: true,
                    data: JSON.parse(cachedData)
                });
            }

            // Cache miss - intercept res.json to store response
            const originalJson = res.json.bind(res);

            res.json = (data) => {
                // Store in cache with automatic expiration (setEx)
                redisClient.setEx(key, duration, JSON.stringify(data))
                    .catch(err => console.error('Cache error:', err));

                originalJson(data);
            };

            next();
        } catch (error) {
            console.error('Cache middleware error:', error);
            next(); // Continue without caching on error
        }
    };
};

// ======================================== EXPENSIVE OPERATION SIMULATION
// Simulates slow database query or external API call
const getExpensiveData = async () => {
    await new Promise(resolve => setTimeout(resolve, 2000)); // 2-second delay
    return {
        users: [
            { id: 1, name: 'Alice', email: 'alice@example.com' },
            { id: 2, name: 'Bob', email: 'bob@example.com' }
        ],
        timestamp: new Date().toISOString()
    };
};

// ======================================== CACHED ROUTES
// GET route with 60-second cache duration
app.get('/api/users', cacheMiddleware(60), async (req, res) => {
    console.log('üîç Fetching data from source...');
    const data = await getExpensiveData();
    res.json(data);
});

// ======================================== CACHE INVALIDATION
// POST route that invalidates specific cache entry
app.post('/api/users', async (req, res) => {
    // Create user logic here...

    // Remove cached data for /api/users after mutation
    await redisClient.del('cache:/api/users');
    console.log('üóëÔ∏è Cache invalidated');

    res.status(201).json({ message: 'User created' });
});

// ======================================== BULK CACHE CLEARING
// Clear all cache entries matching pattern
app.post('/api/cache/clear', async (req, res) => {
    const keys = await redisClient.keys('cache:*'); // Find all cache keys
    if (keys.length > 0) {
        await redisClient.del(keys); // Delete in bulk
    }
    res.json({ message: `Cleared ${keys.length} cache entries` });
});

app.listen(3000, () => console.log('Cached API running on port 3000'));
</code></pre>
            </div>
        </details>

    <h4>2. Rate Limiting with express-rate-limit</h4>
    <p><strong>Description:</strong> Protect your API from abuse by limiting the number of requests per IP address or user. This implementation shows multiple rate limiting strategies including general limits, strict authentication limits, tiered limits based on user subscription levels, and Redis-backed distributed rate limiting.</p>

    <!-- SIMPLIFIED VERSION -->
    <div class="code-block">
        <div class="code-header">
            <span>JavaScript - Rate Limiting Basics (Simplified)</span>
            <button class="copy-btn" onclick="copyCode(this, 'code-d6-2-simple')">Copy</button>
        </div>
        <pre><code id="code-d6-2-simple"
                  class="language-javascript"
                  data-type="performance"
                  data-description="Essential rate limiting with general and auth-specific limits">const express = require('express');
const rateLimit = require('express-rate-limit');
const app = express();
app.use(express.json());

// ======================================== GENERAL RATE LIMITER
// 100 requests per 15 minutes for all routes
const generalLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100, // Limit each IP to 100 requests
    message: {
        error: 'Too many requests',
        message: 'You have exceeded the 100 requests in 15 minutes limit!'
    },
    standardHeaders: true, // Return rate limit info in RateLimit-* headers
    legacyHeaders: false
});

// ======================================== STRICT AUTH LIMITER
// 5 attempts per 15 minutes for login endpoints
const authLimiter = rateLimit({
    windowMs: 15 * 60 * 1000,
    max: 5,
    skipSuccessfulRequests: true, // Only count failed attempts
    message: {
        error: 'Too many login attempts',
        message: 'Account temporarily locked. Try again in 15 minutes.'
    }
});

// ======================================== APPLY LIMITERS
// Apply general limiter to all API routes
app.use('/api/', generalLimiter);

// Apply strict limiter to authentication
app.post('/api/auth/login', authLimiter, (req, res) => {
    res.json({ message: 'Login successful' });
});

app.listen(3000, () => console.log('Rate-limited API running'));
</code></pre>
    </div>

    <details>
        <summary>üìÑ View Full Rate Limiting Implementation (with Redis, tiered limits, and monitoring)</summary>

        <div class="code-block">
            <div class="code-header">
                <span>JavaScript - Advanced Rate Limiting Strategies</span>
                <button class="copy-btn" onclick="copyCode(this, 'code-d6-2')">Copy</button>
            </div>
            <pre class="line-numbers"><code id="code-d6-2"
                  class="language-javascript"
                  data-type="performance"
                  data-description="Production-grade rate limiting with Redis store, tiered limits, and custom handlers">const express = require('express');
const rateLimit = require('express-rate-limit');
const app = express();
app.use(express.json());

// ======================================== GENERAL RATE LIMITER
// 100 requests per 15 minutes for standard API access
const generalLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100, // Limit each IP to 100 requests per window
    message: {
        error: 'Too many requests',
        message: 'You have exceeded the 100 requests in 15 minutes limit!',
        retryAfter: '15 minutes'
    },
    standardHeaders: true, // Return rate limit info in RateLimit-* headers
    legacyHeaders: false, // Disable X-RateLimit-* headers
    handler: (req, res) => {
        // Custom error response when limit exceeded
        res.status(429).json({
            error: 'Too Many Requests',
            message: 'Rate limit exceeded. Please try again later.',
            retryAfter: req.rateLimit.resetTime
        });
    }
});

// ======================================== STRICT AUTH LIMITER
// 5 attempts per 15 minutes for authentication endpoints
const authLimiter = rateLimit({
    windowMs: 15 * 60 * 1000,
    max: 5,
    skipSuccessfulRequests: true, // Only count failed login attempts
    message: {
        error: 'Too many login attempts',
        message: 'Account temporarily locked. Try again in 15 minutes.'
    }
});

// ======================================== REDIS-BACKED RATE LIMITER
// Distributed rate limiting using Redis (for multi-server deployments)
const RedisStore = require('rate-limit-redis');
const redis = require('redis');
const redisClient = redis.createClient();

const redisLimiter = rateLimit({
    store: new RedisStore({
        client: redisClient,
        prefix: 'rate_limit:' // Namespace for rate limit keys
    }),
    windowMs: 60 * 1000, // 1 minute
    max: 20 // 20 requests per minute per IP
});

// ======================================== APPLY GLOBAL LIMITER
// Apply general limiter to all API routes
app.use('/api/', generalLimiter);

// ======================================== AUTHENTICATION ROUTE
// Stricter limit for login to prevent brute force attacks
app.post('/api/auth/login', authLimiter, (req, res) => {
    // Login logic here
    res.json({ message: 'Login successful' });
});

// ======================================== TIERED RATE LIMITING
// Different limits based on user subscription tier
const createTieredLimiter = (req, res, next) => {
    const userTier = req.user?.tier || 'free'; // Default to free tier

    // Define limits per tier
    const limits = {
        free: { windowMs: 60 * 60 * 1000, max: 100 },    // 100 requests/hour
        premium: { windowMs: 60 * 60 * 1000, max: 1000 }, // 1000 requests/hour
        enterprise: { windowMs: 60 * 60 * 1000, max: 10000 } // 10000 requests/hour
    };

    // Create and apply limiter based on user tier
    const limiter = rateLimit(limits[userTier]);
    limiter(req, res, next);
};

app.get('/api/data', createTieredLimiter, (req, res) => {
    res.json({ data: 'Your data here' });
});

// ======================================== RATE LIMIT STATUS ENDPOINT
// Check current rate limit status for debugging/monitoring
app.get('/api/rate-limit/status', (req, res) => {
    res.json({
        limit: req.rateLimit.limit,
        remaining: req.rateLimit.remaining,
        resetTime: new Date(req.rateLimit.resetTime)
    });
});

app.listen(3000, () => console.log('Rate-limited API running on port 3000'));
</code></pre>
            </div>
        </details>

    <h4>3. HTTP Cache Headers & ETags</h4>
    <p><strong>Description:</strong> Use HTTP caching mechanisms to reduce bandwidth and improve performance. ETags enable conditional requests, while Cache-Control headers define caching behavior. This example demonstrates ETag generation, conditional GET requests, Last-Modified headers, and appropriate cache directives for different content types.</p>

    <!-- SIMPLIFIED VERSION -->
    <div class="code-block">
        <div class="code-header">
            <span>JavaScript - HTTP Caching Essentials (Simplified)</span>
            <button class="copy-btn" onclick="copyCode(this, 'code-d6-3-simple')">Copy</button>
        </div>
        <pre><code id="code-d6-3-simple"
                  class="language-javascript"
                  data-type="performance"
                  data-description="Essential HTTP caching with ETags and Cache-Control headers">const express = require('express');
const crypto = require('crypto');
const app = express();

// ======================================== ETAG GENERATION
// Generate unique hash from content
const generateETag = (content) => {
    return crypto
        .createHash('md5')
        .update(JSON.stringify(content))
        .digest('hex');
};

// ======================================== STATIC CONTENT WITH CACHE-CONTROL
// Public content cached for 1 hour
app.get('/api/static/config', (req, res) => {
    res.set('Cache-Control', 'public, max-age=3600');
    res.json({
        apiVersion: '2.0',
        features: ['auth', 'caching', 'rate-limiting']
    });
});

// ======================================== CONDITIONAL GET WITH ETAG
// Check ETag before sending full response
app.get('/api/data', (req, res) => {
    const data = { users: [], timestamp: Date.now() };
    const etag = generateETag(data);

    res.set('ETag', etag);
    res.set('Cache-Control', 'max-age=60');

    // Return 304 if content unchanged
    if (req.headers['if-none-match'] === etag) {
        return res.status(304).end();
    }

    res.json(data);
});

// ======================================== SENSITIVE DATA - NO CACHE
// Never cache authentication or session data
app.get('/api/auth/session', (req, res) => {
    res.set('Cache-Control', 'no-store, no-cache, must-revalidate, private');
    res.json({ sessionId: 'abc123', expiresAt: new Date() });
});

app.listen(3000, () => console.log('HTTP cached API running'));
</code></pre>
    </div>

    <details>
        <summary>üìÑ View Full HTTP Caching Implementation (with ETag middleware and Last-Modified)</summary>

        <div class="code-block">
            <div class="code-header">
                <span>JavaScript - Complete HTTP Caching Strategy</span>
                <button class="copy-btn" onclick="copyCode(this, 'code-d6-3')">Copy</button>
            </div>
            <pre class="line-numbers"><code id="code-d6-3"
                  class="language-javascript"
                  data-type="performance"
                  data-description="Production-ready HTTP caching with ETag middleware, Last-Modified, and comprehensive Cache-Control strategies">const express = require('express');
const crypto = require('crypto');
const app = express();

// ======================================== ETAG GENERATION
// Generate MD5 hash from content for cache validation
const generateETag = (content) => {
    return crypto
        .createHash('md5')
        .update(JSON.stringify(content))
        .digest('hex');
};

// ======================================== ETAG MIDDLEWARE
// Automatically add ETag support to all JSON responses
const etagMiddleware = (req, res, next) => {
    const originalJson = res.json.bind(res);

    res.json = (data) => {
        const etag = generateETag(data);

        // Set ETag header for cache validation
        res.set('ETag', etag);

        // Check if client's cached version is still valid
        const clientEtag = req.headers['if-none-match'];

        if (clientEtag === etag) {
            // Content hasn't changed - return 304 Not Modified
            return res.status(304).end();
        }

        // Content changed - send new data
        originalJson(data);
    };

    next();
};

app.use(etagMiddleware);

// ======================================== STATIC/PUBLIC CONTENT CACHING
// Cache static configuration for 1 hour, allow stale content
app.get('/api/static/config', (req, res) => {
    // public: can be cached by CDNs and proxies
    // max-age: cache for 3600 seconds (1 hour)
    // stale-while-revalidate: can serve stale for 24 hours while revalidating
    res.set('Cache-Control', 'public, max-age=3600, stale-while-revalidate=86400');

    res.json({
        apiVersion: '2.0',
        features: ['auth', 'caching', 'rate-limiting']
    });
});

// ======================================== USER-SPECIFIC CONTENT CACHING
// Private cache with Last-Modified header
app.get('/api/users/:id', (req, res) => {
    // private: only user's browser can cache
    // max-age: cache for 300 seconds (5 minutes)
    // must-revalidate: must check with server when stale
    res.set('Cache-Control', 'private, max-age=300, must-revalidate');

    const user = {
        id: req.params.id,
        name: 'Alice',
        email: 'alice@example.com',
        lastModified: '2024-01-15T10:00:00Z'
    };

    // Set Last-Modified header for time-based cache validation
    res.set('Last-Modified', new Date(user.lastModified).toUTCString());

    // Check If-Modified-Since header from client
    const ifModifiedSince = req.headers['if-modified-since'];
    if (ifModifiedSince) {
        const modifiedTime = new Date(user.lastModified).getTime();
        const requestTime = new Date(ifModifiedSince).getTime();

        // Return 304 if resource not modified since request time
        if (modifiedTime <= requestTime) {
            return res.status(304).end();
        }
    }

    res.json(user);
});

// ======================================== SENSITIVE DATA - NO CACHING
// Never cache authentication, session, or personal data
app.get('/api/auth/session', (req, res) => {
    // no-store: don't cache at all
    // no-cache: always revalidate with server
    // must-revalidate: strict revalidation when stale
    // private: only user's browser, not CDNs
    res.set('Cache-Control', 'no-store, no-cache, must-revalidate, private');
    res.set('Pragma', 'no-cache'); // HTTP/1.0 compatibility
    res.set('Expires', '0'); // Legacy header

    res.json({ sessionId: 'abc123', expiresAt: new Date() });
});

// ======================================== CONDITIONAL GET WITH ETAG
// Manual ETag validation for specific endpoint
app.get('/api/data', (req, res) => {
    const data = { users: [], timestamp: Date.now() };
    const etag = generateETag(data);

    res.set('ETag', etag);
    res.set('Cache-Control', 'max-age=60'); // Cache for 1 minute

    // Check If-None-Match header from client
    if (req.headers['if-none-match'] === etag) {
        return res.status(304).end(); // Not modified
    }

    res.json(data);
});

app.listen(3000, () => console.log('HTTP cached API running on port 3000'));
</code></pre>
            </div>
        </details>

    <div class="storage-demo">
        <h4>üíæ localStorage Practical: Client-Side Performance Tracking</h4>
        <p><strong>Description:</strong> Track API performance metrics on the client side using localStorage. Monitor response times, cache hit rates, and identify slow endpoints. This performance monitor wraps fetch calls to automatically record metrics and provides statistical analysis.</p>

        <!-- SIMPLIFIED VERSION -->
        <div class="code-block">
            <div class="code-header">
                <span>JavaScript - Performance Monitor (Simplified)</span>
                <button class="copy-btn" onclick="copyCode(this, 'storage-d6-simple')">Copy</button>
            </div>
            <pre><code id="storage-d6-simple"
                  class="language-javascript"
                  data-type="performance"
                  data-description="Essential performance tracking with localStorage persistence">// ======================================== PERFORMANCE MONITOR CLASS
// Track API response times and cache efficiency
const PERF_KEY = 'day6_performance_metrics';

class PerformanceMonitor {
    constructor() {
        // Load existing metrics from localStorage
        const data = localStorage.getItem(PERF_KEY);
        this.metrics = data ? JSON.parse(data) : {
            requests: [],
            cacheHits: 0,
            cacheMisses: 0
        };
    }

    // ======================================== TRACKED FETCH
    // Wrap fetch to measure performance
    async trackedFetch(url, options = {}) {
        const startTime = performance.now();

        try {
            const response = await fetch(url, options);
            const duration = performance.now() - startTime;

            // Check if response was cached (304 or X-Cache header)
            const wasCached = response.headers.get('X-Cache') === 'HIT' ||
                            response.status === 304;

            // Record metrics
            this.metrics.requests.push({
                url,
                status: response.status,
                duration,
                cached: wasCached,
                timestamp: new Date().toISOString()
            });

            if (wasCached) {
                this.metrics.cacheHits++;
            } else {
                this.metrics.cacheMisses++;
            }

            // Save to localStorage (keep last 100 entries)
            if (this.metrics.requests.length > 100) {
                this.metrics.requests = this.metrics.requests.slice(-100);
            }
            localStorage.setItem(PERF_KEY, JSON.stringify(this.metrics));

            return response;
        } catch (error) {
            // Record error
            this.metrics.requests.push({
                url,
                status: 'error',
                error: error.message,
                timestamp: new Date().toISOString()
            });
            localStorage.setItem(PERF_KEY, JSON.stringify(this.metrics));
            throw error;
        }
    }

    // ======================================== GET STATISTICS
    getStats() {
        const durations = this.metrics.requests
            .map(r => r.duration)
            .filter(d => d);

        return {
            totalRequests: this.metrics.requests.length,
            cacheHitRate: (this.metrics.cacheHits /
                (this.metrics.cacheHits + this.metrics.cacheMisses) * 100).toFixed(2),
            averageResponseTime: (durations.reduce((a, b) => a + b, 0) /
                durations.length).toFixed(2),
            errors: this.metrics.requests.filter(r => r.status === 'error').length
        };
    }
}

// ======================================== USAGE
const perfMonitor = new PerformanceMonitor();

// Use instead of regular fetch
async function getUsers() {
    const response = await perfMonitor.trackedFetch('/api/users');
    return response.json();
}

// View statistics
console.log('Performance Stats:', perfMonitor.getStats());
</code></pre>
        </div>

        <details>
            <summary>üìÑ View Full Performance Monitor (with percentile calculations and detailed metrics)</summary>

            <div class="code-block">
                <div class="code-header">
                    <span>JavaScript - Complete Performance Monitoring System</span>
                    <button class="copy-btn" onclick="copyCode(this, 'storage-d6')">Copy</button>
                </div>
                <pre class="line-numbers"><code id="storage-d6"
                      class="language-javascript"
                      data-type="performance"
                      data-description="Production-ready performance monitoring with detailed metrics, percentiles, and localStorage persistence">// Performance Tracker - Monitor API response times
const PERF_KEY = 'day6_performance_metrics';
const MAX_SAMPLES = 100;

// ======================================== PERFORMANCE MONITOR CLASS
class PerformanceMonitor {
    constructor() {
        this.metrics = this.loadMetrics();
    }

    // ======================================== LOAD METRICS
    // Restore metrics from localStorage on initialization
    loadMetrics() {
        const data = localStorage.getItem(PERF_KEY);
        return data ? JSON.parse(data) : {
            requests: [],
            cacheHits: 0,
            cacheMisses: 0
        };
    }

    // ======================================== SAVE METRICS
    // Persist metrics to localStorage with size limit
    saveMetrics() {
        // Keep only last 100 requests to prevent storage bloat
        if (this.metrics.requests.length > MAX_SAMPLES) {
            this.metrics.requests = this.metrics.requests.slice(-MAX_SAMPLES);
        }
        localStorage.setItem(PERF_KEY, JSON.stringify(this.metrics));
    }

    // ======================================== TRACKED FETCH
    // Wrap fetch to automatically measure and record performance
    async trackedFetch(url, options = {}) {
        const startTime = performance.now();
        const startMark = `fetch-start-${Date.now()}`;
        const endMark = `fetch-end-${Date.now()}`;

        // Use Performance API marks for detailed profiling
        performance.mark(startMark);

        try {
            const response = await fetch(url, options);
            performance.mark(endMark);

            const duration = performance.now() - startTime;

            // Detect if response came from cache
            const wasCached = response.headers.get('X-Cache') === 'HIT' ||
                            response.status === 304;

            // Track detailed request metrics
            this.recordRequest({
                url,
                method: options.method || 'GET',
                status: response.status,
                duration,
                cached: wasCached,
                timestamp: new Date().toISOString(),
                size: response.headers.get('Content-Length')
            });

            // Update cache statistics
            if (wasCached) {
                this.metrics.cacheHits++;
            } else {
                this.metrics.cacheMisses++;
            }

            this.saveMetrics();
            return response;

        } catch (error) {
            performance.mark(endMark);
            const duration = performance.now() - startTime;

            // Record failed request
            this.recordRequest({
                url,
                method: options.method || 'GET',
                status: 'error',
                duration,
                error: error.message,
                timestamp: new Date().toISOString()
            });

            this.saveMetrics();
            throw error;
        }
    }

    // ======================================== RECORD REQUEST
    recordRequest(data) {
        this.metrics.requests.push(data);
    }

    // ======================================== CALCULATE STATISTICS
    // Generate comprehensive performance statistics
    getStats() {
        const requests = this.metrics.requests;
        const durations = requests.map(r => r.duration).filter(d => d);

        const stats = {
            totalRequests: requests.length,
            cacheHitRate: this.metrics.cacheHits /
                (this.metrics.cacheHits + this.metrics.cacheMisses) * 100,
            averageResponseTime: durations.reduce((a, b) => a + b, 0) / durations.length,
            p95: this.percentile(durations, 95), // 95th percentile
            p99: this.percentile(durations, 99), // 99th percentile
            slowestRequests: requests
                .sort((a, b) => b.duration - a.duration)
                .slice(0, 5), // Top 5 slowest requests
            errors: requests.filter(r => r.status === 'error').length
        };

        return stats;
    }

    // ======================================== PERCENTILE CALCULATION
    // Calculate percentile (e.g., p95, p99) for response times
    percentile(arr, p) {
        const sorted = [...arr].sort((a, b) => a - b);
        const index = Math.ceil((p / 100) * sorted.length) - 1;
        return sorted[index];
    }

    // ======================================== RESET METRICS
    // Clear all stored metrics
    reset() {
        this.metrics = { requests: [], cacheHits: 0, cacheMisses: 0 };
        localStorage.removeItem(PERF_KEY);
    }
}

// ======================================== USAGE EXAMPLE
const perfMonitor = new PerformanceMonitor();

// Use instead of regular fetch
async function getUsers() {
    const response = await perfMonitor.trackedFetch('/api/users');
    return response.json();
}

// View detailed statistics
console.log('Performance Stats:', perfMonitor.getStats());
console.table(perfMonitor.metrics.requests.slice(-10)); // Last 10 requests
</code></pre>
            </div>
        </details>
    </div>

    <div class="exercise">
        <h4>üèãÔ∏è Exercise: Implement Complete Caching Strategy</h4>
        <p><strong>Scenario:</strong> You have a products API that gets hit frequently. Implement a multi-layer caching strategy.</p>
        <p><strong>Task:</strong> Create an API with Redis caching, HTTP cache headers, and cache invalidation.</p>
        <p><strong>Requirements:</strong></p>
        <ul>
            <li>GET /api/products - Cache for 5 minutes in Redis</li>
            <li>Add ETag support for conditional requests</li>
            <li>POST/PUT/DELETE should invalidate the cache</li>
            <li>Include Cache-Control headers</li>
        </ul>

        <details>
            <summary>üí° Hint</summary>
            <p>Combine Redis middleware for server-side caching with ETag generation for client-side caching. Use cache invalidation on mutations.</p>
        </details>

        <details>
            <summary>‚úÖ Solution</summary>
            <p><strong>Description:</strong> Complete multi-layer caching solution combining Redis server-side caching with ETag client-side validation. Includes automatic cache invalidation on mutations and comprehensive Cache-Control headers.</p>

            <!-- SIMPLIFIED SOLUTION -->
            <div class="code-block">
                <div class="code-header">
                    <span>JavaScript - Multi-Layer Caching (Simplified)</span>
                    <button class="copy-btn" onclick="copyCode(this, 'solution-d6-simple')">Copy</button>
                </div>
                <pre><code id="solution-d6-simple"
                      class="language-javascript"
                      data-type="performance"
                      data-description="Essential multi-layer caching with Redis and ETag support">const express = require('express');
const redis = require('redis');
const crypto = require('crypto');
const app = express();
app.use(express.json());

const redisClient = redis.createClient();
redisClient.connect();

let products = [{ id: 1, name: 'Laptop', price: 999 }];

// ======================================== MULTI-LAYER CACHE MIDDLEWARE
const multiLayerCache = (duration) => {
    return async (req, res, next) => {
        const cacheKey = `cache:${req.originalUrl}`;

        // Layer 1: Check Redis cache
        const cached = await redisClient.get(cacheKey);
        if (cached) {
            const etag = crypto.createHash('md5').update(cached).digest('hex');
            res.set('ETag', etag);
            res.set('X-Cache', 'HIT');

            // Layer 2: ETag validation
            if (req.headers['if-none-match'] === etag) {
                return res.status(304).end(); // Not Modified
            }

            return res.json(JSON.parse(cached));
        }

        // Cache miss - store response
        const originalJson = res.json.bind(res);
        res.json = (data) => {
            const content = JSON.stringify(data);
            redisClient.setEx(cacheKey, duration, content);
            res.set('X-Cache', 'MISS');
            originalJson(data);
        };
        next();
    };
};

// ======================================== CACHE INVALIDATION
const invalidateCache = async (pattern = 'cache:*') => {
    const keys = await redisClient.keys(pattern);
    if (keys.length > 0) await redisClient.del(keys);
};

// ======================================== ROUTES
// GET - with 5-minute cache
app.get('/api/products', multiLayerCache(300), (req, res) => {
    res.json({ products, timestamp: new Date().toISOString() });
});

// POST - invalidate cache
app.post('/api/products', async (req, res) => {
    products.push({ id: products.length + 1, ...req.body });
    await invalidateCache('cache:/api/products*');
    res.status(201).json({ message: 'Created' });
});

// PUT - invalidate cache
app.put('/api/products/:id', async (req, res) => {
    const index = products.findIndex(p => p.id === parseInt(req.params.id));
    if (index !== -1) {
        products[index] = { ...products[index], ...req.body };
        await invalidateCache('cache:/api/products*');
        res.json(products[index]);
    } else {
        res.status(404).json({ error: 'Not found' });
    }
});

// DELETE - invalidate cache
app.delete('/api/products/:id', async (req, res) => {
    products = products.filter(p => p.id !== parseInt(req.params.id));
    await invalidateCache('cache:/api/products*');
    res.status(204).send();
});

app.listen(3000);
</code></pre>
            </div>

            <details>
                <summary>üìÑ View Complete Multi-Layer Caching Solution (with full error handling)</summary>

                <div class="code-block">
                    <div class="code-header">
                        <span>JavaScript - Production Multi-Layer Caching</span>
                        <button class="copy-btn" onclick="copyCode(this, 'solution-d6')">Copy</button>
                    </div>
                    <pre class="line-numbers"><code id="solution-d6"
                          class="language-javascript"
                          data-type="performance"
                          data-description="Complete multi-layer caching with Redis, ETags, error handling, and cache invalidation">const express = require('express');
const redis = require('redis');
const crypto = require('crypto');
const app = express();
app.use(express.json());

// ======================================== REDIS SETUP
const redisClient = redis.createClient();
redisClient.connect();

// ======================================== DATA STORE
let products = [
    { id: 1, name: 'Laptop', price: 999, lastModified: Date.now() }
];

// ======================================== MULTI-LAYER CACHE MIDDLEWARE
// Combines Redis server-side cache with ETag client-side validation
const multiLayerCache = (duration) => {
    return async (req, res, next) => {
        const cacheKey = `cache:${req.originalUrl}`;

        // ======================================== LAYER 1: REDIS CACHE
        try {
            const cached = await redisClient.get(cacheKey);
            if (cached) {
                const data = JSON.parse(cached);
                const etag = crypto.createHash('md5').update(cached).digest('hex');

                // Set cache headers
                res.set('ETag', etag);
                res.set('X-Cache', 'HIT'); // Indicate cache hit
                res.set('Cache-Control', `public, max-age=${duration}`);

                // ======================================== LAYER 2: ETAG VALIDATION
                // Check if client's cached version is still valid
                if (req.headers['if-none-match'] === etag) {
                    return res.status(304).end(); // Not Modified
                }

                return res.json(data);
            }
        } catch (error) {
            console.error('Redis error:', error);
            // Continue without cache on Redis error
        }

        // ======================================== CACHE MISS HANDLING
        // Intercept response to store in cache
        const originalJson = res.json.bind(res);
        res.json = (data) => {
            const content = JSON.stringify(data);
            const etag = crypto.createHash('md5').update(content).digest('hex');

            // Store in Redis with automatic expiration
            redisClient.setEx(cacheKey, duration, content);

            // Set response headers
            res.set('ETag', etag);
            res.set('X-Cache', 'MISS'); // Indicate cache miss
            res.set('Cache-Control', `public, max-age=${duration}`);

            originalJson(data);
        };

        next();
    };
};

// ======================================== CACHE INVALIDATION HELPER
// Clear cache entries matching a pattern
const invalidateCache = async (pattern = 'cache:*') => {
    const keys = await redisClient.keys(pattern);
    if (keys.length > 0) {
        await redisClient.del(keys);
    }
    console.log(`Invalidated ${keys.length} cache entries`);
};

// ======================================== GET ROUTE (CACHED)
// Retrieve products with 5-minute cache (300 seconds)
app.get('/api/products', multiLayerCache(300), (req, res) => {
    res.json({
        products,
        timestamp: new Date().toISOString()
    });
});

// ======================================== POST ROUTE (INVALIDATE)
// Create new product and invalidate cache
app.post('/api/products', async (req, res) => {
    const newProduct = {
        id: products.length + 1,
        ...req.body,
        lastModified: Date.now()
    };
    products.push(newProduct);

    // Clear all product cache entries
    await invalidateCache('cache:/api/products*');

    res.status(201).json(newProduct);
});

// ======================================== PUT ROUTE (INVALIDATE)
// Update product and invalidate cache
app.put('/api/products/:id', async (req, res) => {
    const id = parseInt(req.params.id);
    const index = products.findIndex(p => p.id === id);

    if (index === -1) {
        return res.status(404).json({ error: 'Not found' });
    }

    // Update product with new lastModified timestamp
    products[index] = { ...products[index], ...req.body, lastModified: Date.now() };

    // Clear cache after update
    await invalidateCache('cache:/api/products*');

    res.json(products[index]);
});

// ======================================== DELETE ROUTE (INVALIDATE)
// Delete product and invalidate cache
app.delete('/api/products/:id', async (req, res) => {
    products = products.filter(p => p.id !== parseInt(req.params.id));

    // Clear cache after deletion
    await invalidateCache('cache:/api/products*');

    res.status(204).send();
});

app.listen(3000);
</code></pre>
                </div>
            </details>
        </details>
    </div>

    <div class="quiz">
        <h3>‚úÖ Check Your Knowledge</h3>

        <div class="quiz-question">
            <p><strong>Q1:</strong> What HTTP status code indicates "Not Modified" for conditional requests?</p>
            <div class="quiz-options">
                <label><input type="radio" name="d6q1" value="a"> A) 200</label>
                <label><input type="radio" name="d6q1" value="b"> B) 304</label>
                <label><input type="radio" name="d6q1" value="c"> C) 404</label>
            </div>
            <button class="check-answer" onclick="checkAnswer('d6q1', 'b', 'd6q1-fb')">Check Answer</button>
            <div class="feedback" id="d6q1-fb"></div>
        </div>

        <div class="quiz-question">
            <p><strong>Q2:</strong> What's the purpose of rate limiting?</p>
            <div class="quiz-options">
                <label><input type="radio" name="d6q2" value="a"> A) Make the API slower</label>
                <label><input type="radio" name="d6q2" value="b"> B) Prevent abuse and ensure fair usage</label>
                <label><input type="radio" name="d6q2" value="c"> C) Cache responses</label>
            </div>
            <button class="check-answer" onclick="checkAnswer('d6q2', 'b', 'd6q2-fb')">Check Answer</button>
            <div class="feedback" id="d6q2-fb"></div>
        </div>

        <div class="quiz-question">
            <p><strong>Q3:</strong> Which cache header value prevents caching entirely?</p>
            <div class="quiz-options">
                <label><input type="radio" name="d6q3" value="a"> A) Cache-Control: public</label>
                <label><input type="radio" name="d6q3" value="b"> B) Cache-Control: max-age=3600</label>
                <label><input type="radio" name="d6q3" value="c"> C) Cache-Control: no-store</label>
            </div>
            <button class="check-answer" onclick="checkAnswer('d6q3', 'c', 'd6q3-fb')">Check Answer</button>
            <div class="feedback" id="d6q3-fb"></div>
        </div>
    </div>

    <div class="takeaways">
        <h3>üéØ Key Takeaways</h3>
        <ul>
            <li>Multi-layer caching (Redis + HTTP headers) provides best performance</li>
            <li>ETags enable efficient conditional requests (304 Not Modified)</li>
            <li>Rate limiting protects your API from abuse and ensures fair usage</li>
            <li>Always invalidate cache after data mutations (POST/PUT/DELETE)</li>
            <li>Use appropriate Cache-Control directives for different content types</li>
        </ul>
        <p><strong>Tomorrow:</strong> API Documentation & Testing - OpenAPI/Swagger, automated testing, and deployment.</p>
    </div>

    <button class="complete-day" onclick="completeDay(6)">‚úì Mark Day 6 Complete</button>
</div>
